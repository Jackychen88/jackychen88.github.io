<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ABAP类的集成多态重载]]></title>
    <url>%2F2019%2F01%2F01%2FABAP%E7%B1%BB%E7%9A%84%E9%9B%86%E6%88%90%E5%A4%9A%E6%80%81%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[以下代码将列举以下4种类的写法 定义基类 定义子类 定义抽象类 最终类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081REPORT demo_list_hide NO STANDARD PAGE HEADING.*-----------------继承------------class superclass definition. 定义基类 public section. data para(30) type c value &apos;this is super method!&apos;. methods write_first. methods write.endclass.class subclass definition inheriting from superclass. 定义派生类 public section. methods write_first redefinition. 定义重载方法 methods write_second.endclass.class superclass implementation. method write_first. write:/ para. skip. endmethod. method write. write:/ &apos;super method not inheriting!&apos;. endmethod.endclass.class subclass implementation. method write_first. call method super-&gt;write_first. 通过super调用基类的方法，反之me endmethod. method write_second. para = &apos;the redifinition method!&apos;. call method me-&gt;write_first. 通过me调用自身的方法 endmethod.endclass.*---------------定义抽象类---------------------------------------*-基类有多个派生类的时候，所有操作都在派生类中实现，并不需要通过基类定义对象实例，可以将基类定义为一个模板，声明为抽象类。*-抽象类包含至少一个抽象方法，不能通过create object声明对象实例。抽象方法只包含方法的定义，不包含具体的实现，实现在子类中。class superclass2 definition abstract. 定义一个抽象类 public section. data abs(40) value &apos;this is a super abstract!&apos;. methods write_first abstract.定义抽象方法endclass.class subclass2 definition inheriting from superclass2. public section. methods write_first redefinition. methods write_second.endclass.class subclass2 implementation. method write_first. write:/ &apos;abstract:&apos;. write:/ abs. skip. endmethod. method write_second. write:/ &apos;this is the second method.&apos;. endmethod.endclass.data new2 type ref to subclass2.data new type ref to subclass.start-of-selection. create object new. call method: new-&gt;write_first, new-&gt;write_second, new-&gt;write.派生类的实例化对象可以调用自身的所有方法，而且可以调用基类的方法，但是方法重载之后，不能通过实例化对象直接调用该方法，需用supper来实现。create object new2.call method: new2-&gt;write_first, new2-&gt;write_second.*-----------------最终类与最终方法------------：最终类和最终方法都是不可以继承的，为了防止多级别的派生导致的语义语法冲突。class finalclass definition final.…………methods final_write final.endclass.]]></content>
      <tags>
        <tag>ABAP</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ABAP OO中等号的含义]]></title>
    <url>%2F2019%2F01%2F01%2FABAP-OO%E4%B8%AD%E7%AD%89%E5%8F%B7%E7%9A%84%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[“=” 同类型赋值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455*&amp;---------------------------------------------------------------------**&amp; Report Z_WYS_TYPEREF01*&amp;作者:永上*&amp;---------------------------------------------------------------------**&amp;同类之间用 = 赋值*&amp;*&amp;---------------------------------------------------------------------*REPORT z_wys_typeref01. *----------------------------------------------------------------------** CLASS CP DEFINITION*----------------------------------------------------------------------**c_parent 定义*----------------------------------------------------------------------*CLASS c_parent DEFINITION .&quot; 父类 PUBLIC SECTION. DATA i TYPE i. DATA s TYPE string. METHODS constructor. METHODS zwrite. PRIVATE SECTION.ENDCLASS. &quot;A DEFINITION*----------------------------------------------------------------------** CLASS c_parent IMPLEMENTATION*----------------------------------------------------------------------**c_parent 实现*----------------------------------------------------------------------*CLASS c_parent IMPLEMENTATION. METHOD constructor. WRITE / &apos;父类创建!&apos;. ENDMETHOD. &quot;constructor METHOD zwrite . WRITE / &apos;父类write.&apos;. ENDMETHOD. &quot;destructor &quot;destructorENDCLASS . &quot;a START-OF-SELECTION. DATA cp TYPE REF TO c_parent . &quot; DATA cp2 TYPE REF TO c_parent . &quot; CREATE OBJECT cp. &quot;cp 实例化, 系统会在后台创建一个 &quot;c_parent类型的实例(比如命名为c_parent_1) &quot;并且让cp 引用这个实例 cp-&gt;zwrite( ). &quot;调用成员函数 cp2 = cp. &quot; 静态声明 cp 和 cp2是相同类型. &quot; cp2 并没有实例化(后台没有创建c_parent_2), &quot; cp2只是引用了cp引用的实例. cp-&gt;i = 10. &quot; cp2-&gt;i也随之改为10. 这就是引用类型的魅力^_^ write: / cp-&gt;i,cp2-&gt;i. cp2-&gt;i = 99. &quot; cp-&gt;i也随之改为99. 这也是引用类型的魅力^_^ write: / cp-&gt;i,cp2-&gt;i. cp2-&gt;zwrite( ). &quot;调用成员函数 “=” 向上转型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374*&amp;---------------------------------------------------------------------**&amp; Report Z_WYS_TYPEREF*&amp;*&amp;---------------------------------------------------------------------**&amp;*&amp; 基类 = 派生类*&amp;---------------------------------------------------------------------*REPORT z_wys_typeref02. *----------------------------------------------------------------------** CLASS CP DEFINITION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_parent DEFINITION .&quot; 基类 PUBLIC SECTION. DATA i TYPE i. DATA s TYPE string. METHODS constructor. METHODS zwrite. PRIVATE SECTION.ENDCLASS. &quot;A DEFINITION*----------------------------------------------------------------------** CLASS c_parent IMPLEMENTATION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_parent IMPLEMENTATION. METHOD constructor. &quot; 父类创建 WRITE / &apos;父类创建!&apos;. ENDMETHOD. METHOD zwrite . WRITE / &apos;父类write.&apos;. ENDMETHOD. &quot;destructor &quot;destructorENDCLASS . &quot;a*----------------------------------------------------------------------** CLASS c_child DEFINITION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_child DEFINITION INHERITING FROM c_parent. PUBLIC SECTION. DATA child_str TYPE string. METHODS constructor . METHODS zwrite REDEFINITION.ENDCLASS. &quot;*----------------------------------------------------------------------** CLASS ac IMPLEMENTATION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_child IMPLEMENTATION. METHOD constructor . &quot; 子类创建 super-&gt;constructor( ).&quot;先调用父类的构造函数 WRITE &apos;子类创建!&apos;. ENDMETHOD. METHOD zwrite . WRITE / &apos;子类write.&apos;. ENDMETHOD. &quot;destructorENDCLASS. &quot;ac IMPLEMENTATIONSTART-OF-SELECTION. DATA cp TYPE REF TO c_parent . &quot; DATA cc TYPE REF TO c_child . &quot; CREATE OBJECT cc .&quot; 创建子类实例 cp = cc. &quot; 父类 = 子类 &quot; 静态声明中&quot;=&quot; 两边类型不匹配, &quot; 但是&quot;=&quot; 左边是右边的基类 &quot; 所以语法检查通过 cp-&gt;zwrite( ). &quot; 调用子类的方法 “?=” 向下转型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283*&amp;---------------------------------------------------------------------**&amp; Report Z_WYS_TYPEREF*&amp;*&amp;---------------------------------------------------------------------**&amp;*&amp; 派生类 = 基类*&amp;---------------------------------------------------------------------*REPORT z_wys_typeref03. *----------------------------------------------------------------------** CLASS CP DEFINITION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_parent DEFINITION .&quot; 父类 PUBLIC SECTION. DATA i TYPE i. DATA s TYPE string. METHODS constructor. METHODS zwrite. PRIVATE SECTION.ENDCLASS. &quot;A DEFINITION*----------------------------------------------------------------------** CLASS c_parent IMPLEMENTATION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_parent IMPLEMENTATION. METHOD constructor. &quot; 父类创建 WRITE / &apos;父类创建!&apos;. ENDMETHOD. METHOD zwrite . WRITE / &apos;父类write.&apos;. ENDMETHOD. &quot;destructor &quot;destructorENDCLASS . &quot;a*----------------------------------------------------------------------** CLASS c_child DEFINITION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_child DEFINITION INHERITING FROM c_parent. PUBLIC SECTION. DATA child_str TYPE string. METHODS constructor . METHODS zwrite REDEFINITION.ENDCLASS. &quot;*----------------------------------------------------------------------** CLASS ac IMPLEMENTATION*----------------------------------------------------------------------***----------------------------------------------------------------------*CLASS c_child IMPLEMENTATION. METHOD constructor . &quot; 子类创建 super-&gt;constructor( ).&quot;先调用父类的构造函数 WRITE &apos;子类创建!&apos;. ENDMETHOD. METHOD zwrite . WRITE / &apos;子类write.&apos;. ENDMETHOD. &quot;destructorENDCLASS. &quot;ac IMPLEMENTATIONSTART-OF-SELECTION. DATA cp TYPE REF TO c_parent . &quot; DATA cc TYPE REF TO c_child . &quot;******************************************************** 错误1&quot; CREATE OBJECT cp .&quot; 创建父类实例&quot; cc = cp. &quot; 子类 = 父类 语法检查出错 &quot; 静态声明中&quot;=&quot; 两边类型不匹配.*************************************************************************************************************** 错误2&quot; CREATE OBJECT cp .&quot; 创建父类实例&quot; cc ?= cp. &quot; 语法检查正确, 但 运行期类型不匹配********************************************************正确 CREATE OBJECT cp type c_child.&quot; 动态创建cp 为c_child cc ?= cp. &quot; 静态语法检查正确, 动态类型一致 cc-&gt;zwrite( ). &quot; 调用子类的方法 总结 举例完毕. 关于 “?=”, SAP 帮助中这么解释的: MOVE source {TO|?TO} destination. destination {=|?=} source. 原文: Both these statements assign the content of the operand source to the data object destination. The variants with the addition TO or the assignment operator = are valid for all assignments between operands that are not reference variables, and for assignments between reference variables for which the static type of source is more specific than or the same as the static type of destination (narrowing cast). 中文: 上述两个声明,用源操作数的数据(source)给目标数据对象赋值(destination). “TO”或者赋值运算符”=” 适用于以下两种情况: 1. 操作对象,包括源和目标对象都不是引用类型 2. 如果是引用类型,源对象和目标对象类型一致(本文例子1)或者源对象要比目标对象更具体(向上转型)--(本文例子2) 原文: Variants with the addition ?TO or the assignment operator ?= (casting operator) must be used if the source and destination are reference variables and the static type of source is more general than the static type of destination (down cast). For assignments between operands that are not reference variables, use of the question mark ? is not permitted. 中文: 使用”?TO”或者赋值运算符”?=”(类型转换操作符)的变式,要同时具备以下两个条件: 1.操作对象,包括源和目标对象, 都是引用类型; 2.并且,源对象的静态类型(data语句声明的类型)要比目标对象更抽象(向下转型).–(本文例子3) 非引用型变量赋值不能用问号操作符. 关键词: ABAP OO object oriented 面向对象 运行时 多态 兼容性赋值 转型 永上]]></content>
      <tags>
        <tag>ABAP</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAP调用ECharts生成图表]]></title>
    <url>%2F2019%2F01%2F01%2FSAP%E8%B0%83%E7%94%A8ECharts%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[获取ECharts你可以通过以下几种方式获取 ECharts： 从官网下载界面选择你需要的版本下载，根据开发者功能和体积上的需求，我们提供了不同打包的下载，如果你在体积上没有要求，可以直接下载完整版本。开发环境建议下载源代码版本，包含了常见的错误提示和警告。 在 ECharts 的 GitHub 上下载最新的 release 版本，解压出来的文件夹里的 dist 目录里可以找到最新版本的 echarts 库。 通过 npm 获取 echarts，npm install echarts –save，详见“在 webpack 中使用 echarts” cdn 引入，你可以在 cdnjs，npmcdn 或者国内的 bootcdn 上找到 ECharts 的最新版本。 引入 EChartsECharts 3 开始不再强制使用 AMD 的方式按需引入，代码里也不再内置 AMD 加载器。因此引入方式简单了很多，只需要像普通的 JavaScript 库一样用 script 标签引入。123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;!-- 引入 ECharts 文件（从上记第四点的网站那个可以直接导入） --&gt; &lt;!--&lt;script src="echarts.min.js"&gt;&lt;/script&gt; --&gt; &lt;script src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.common.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 绘制一个简单的图表在绘图前我们需要为 ECharts 准备一个具备高宽的 DOM 容器。1234&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;&lt;/body&gt; 然后就可以通过 echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图，下面是完整代码。12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.common.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById('main')); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: 'ECharts 入门示例' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['销量'] &#125;, xAxis: &#123; data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果 你也可以直接进入 ECharts Gallery 中查看编辑示例 EChart 结合SAP报表的显示sample123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172*&amp;---------------------------------------------------------------------**&amp; Report YTEST_JK63*&amp;*&amp;---------------------------------------------------------------------**&amp;*&amp;*&amp;---------------------------------------------------------------------*REPORT YTEST_JK63.CLASS LCL_HTML_SHOWER DEFINITION FINAL CREATE PRIVATE . PUBLIC SECTION. CLASS-METHODS FACTORY RETURNING VALUE(OR_HTML_SHOWER) TYPE REF TO LCL_HTML_SHOWER. METHODS SHOW_HTML. PRIVATE SECTION. TYPES: BEGIN OF TY_DATA, NAME TYPE ZNAME, QTY TYPE char1, END OF TY_DATA, TTY_DATA TYPE STANDARD TABLE OF TY_DATA.&quot; WITH UNIQUE KEY NAME. DATA: V_HTML TYPE STRING, T_DATA TYPE TTY_DATA. METHODS: CONSTRUCTOR. METHODS EDIT_DATA.ENDCLASS.CLASS LCL_HTML_SHOWER IMPLEMENTATION. METHOD FACTORY. CREATE OBJECT OR_HTML_SHOWER. ENDMETHOD. METHOD EDIT_DATA. T_DATA = VALUE #( ( NAME = &apos;张三&apos; QTY = &apos;3&apos; ) ( NAME = &apos;李四&apos; QTY = &apos;4&apos; ) ( NAME = &apos;王五&apos; QTY = &apos;5&apos; ) ( NAME = &apos;赵六&apos; QTY = &apos;6&apos; ) ( NAME = &apos;石七&apos; QTY = &apos;7&apos; ) ( NAME = &apos;张八&apos; QTY = &apos;8&apos; ) ). ENDMETHOD. METHOD CONSTRUCTOR.*&lt;!DOCTYPE html&gt;*&lt;html&gt;*&lt;head&gt;* &lt;meta charset=&quot;utf-8&quot;&gt;* &lt;title&gt;ECharts&lt;/title&gt;* &lt;!-- 引入 echarts.js --&gt;*&lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.common.js&quot;&gt;&lt;/script&gt;*&lt;/head&gt;*&lt;body&gt;* &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;* &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;* &lt;script type=&quot;text/javascript&quot;&gt;* // 基于准备好的dom，初始化echarts实例* var myChart = echarts.init(document.getElementById(&apos;main&apos;));** // 指定图表的配置项和数据* var option = &#123;* title: &#123;* text: &apos;ECharts 入门示例&apos;* &#125;,* tooltip: &#123;&#125;,* legend: &#123;* data:[&apos;销量&apos;]* &#125;,* xAxis: &#123;* data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]* &#125;,* yAxis: &#123;&#125;,* series: [&#123;* name: &apos;销量&apos;,* type: &apos;bar&apos;,* data: [5, 20, 36, 10, 10, 20]* &#125;]* &#125;;** // 使用刚指定的配置项和数据显示图表。* myChart.setOption(option);* &lt;/script&gt;*&lt;/body&gt;*&lt;/html&gt; EDIT_DATA( ). ME-&gt;V_HTML =|&lt;!DOCTYPE html&gt;| &amp;&amp;|&lt;html&gt;| &amp;&amp;|&lt;head&gt;| &amp;&amp;| &lt;meta charset=&quot;utf-8&quot;&gt;| &amp;&amp;| &lt;title&gt;ECharts&lt;/title&gt;| &amp;&amp;|&lt;script src=&quot;https://cdn.bootcss.com/echarts/4.2.0-rc.2/echarts-en.common.js&quot;&gt;&lt;/script&gt;| &amp;&amp;|&lt;/head&gt;| &amp;&amp;|&lt;body&gt;| &amp;&amp;| &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;| &amp;&amp;| &lt;script type=&quot;text/javascript&quot;&gt;| &amp;&amp;| var myChart = echarts.init(document.getElementById(&apos;main&apos;));| &amp;&amp;| var option = \&#123; | &amp;&amp;| title: \&#123;| &amp;&amp;| text: &apos;ECharts 入门示例&apos;| &amp;&amp;| \&#125;,| &amp;&amp;| tooltip: \&#123;\&#125;,| &amp;&amp;| legend: \&#123;| &amp;&amp;| data:[&apos;销量&apos;]| &amp;&amp;| \&#125;,| &amp;&amp;| xAxis: \&#123;| &amp;&amp;| data:[| &amp;&amp; REDUCE string( INIT list type string sep = `` FOR wa in me-&gt;T_DATA NEXT list = list &amp;&amp; |&#123; sep &#125;&quot;&#123; wa-name &#125;&quot;| sep = `,` ) &amp;&amp;|]| &amp;&amp;| \&#125;,| &amp;&amp;| yAxis: \&#123;\&#125;,| &amp;&amp;| series: [\&#123;| &amp;&amp;| name: &apos;销量&apos;,| &amp;&amp;| type: &apos;bar&apos;,| &amp;&amp;| data:[| &amp;&amp; REDUCE string( INIT list type string sep = `` FOR wa in me-&gt;T_DATA NEXT list = list &amp;&amp; |&#123; sep &#125;&quot;&#123; wa-qty &#125;&quot;| sep = `,` ) &amp;&amp;|]| &amp;&amp;| \&#125;]| &amp;&amp;| \&#125;;| &amp;&amp;| myChart.setOption(option);| &amp;&amp;| &lt;/script&gt;| &amp;&amp;|&lt;/body&gt;| &amp;&amp;|&lt;/html&gt;|. ENDMETHOD. METHOD SHOW_HTML. CL_ABAP_BROWSER=&gt;SHOW_HTML( HTML_STRING = ME-&gt;V_HTML BUTTONS = CL_ABAP_BROWSER=&gt;NAVIGATE_HTML CONTEXT_MENU = ABAP_TRUE CHECK_HTML = ABAP_FALSE ). ENDMETHOD.ENDCLASS.START-OF-SELECTION. DATA: LO_HTML_SHOWER TYPE REF TO LCL_HTML_SHOWER. LO_HTML_SHOWER = LCL_HTML_SHOWER=&gt;FACTORY( ). LO_HTML_SHOWER-&gt;SHOW_HTML( ).]]></content>
      <tags>
        <tag>ABAP</tag>
        <tag>EChart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown时序图示例]]></title>
    <url>%2F2019%2F01%2F01%2FMarkdown%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[[TOC] 序列图(sequence diagram)时序图解读时序图（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等 角色（Actor） 系统角色，可以是人、及其甚至其他的系统或者子系统。 对象（Object） 对象包括三种命名方式： 第一种方式包括对象名和类名； 第二中方式只显示类名不显示对象名，即表示他是一个匿名对象； 第三种方式只显示对象名不显示类明。 生命线（Lifeline） 生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间 控制焦点（Focus of Control） 控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作。用小矩形表示 消息（Message） 消息一般分为三种 同步消息（Synchronous Message）：消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。（就是程序中的调用） 异步消息（Asynchronous Message）：消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。（就是程序中发消息给消息队列的操作） 返回消息（Return Message）：返回消息表示从过程调用返回 简单sample 代码1+ sequenceDiagram Alice-&gt;&gt;John: Hello John, how are you ? John–&gt;&gt;Alice: Great! Alice-&gt;&gt;John: Hung,you are better . John–&gt;&gt;Alice: yeah, Just not bad.+`1+ **效果**&lt;br&gt; sequenceDiagram Alice-&gt;&gt;John: Hello John, how are you ? John–&gt;&gt;Alice: Great! Alice-&gt;&gt;John: Hung,you are better . John–&gt;&gt;Alice: yeah, Just not bad.1234---## 控制对象的顺序(通过设定参与者(participant)的顺序)+ **代码**&lt;br&gt; +12345678sequenceDiagram participant John participant Alice Alice-&gt;&gt;John: Hello John, how are you ? John--&gt;&gt;Alice: Great! Alice-&gt;&gt;John: Hung,you are better . John--&gt;&gt;Alice: yeah, Just not bad.`+`` 效果1234567sequenceDiagram participant John participant Alice Alice-&gt;&gt;John: Hello John, how are you ? John--&gt;&gt;Alice: Great! Alice-&gt;&gt;John: Hung,you are better . John--&gt;&gt;Alice: yeah, Just not bad. 实线或者虚线的使用 代码1+ sequenceDiagram Alice-&gt;John:连接线 John–&gt;Alice:返回连接线 Alice-&gt;&gt;John: 发送同步调用消息 John–&gt;&gt;Alice:返回同步消息 Alice-xJohn: 发送异步调用消息 John–xAlice: 返回异步消息+12```+ **效果**&lt;br&gt; sequenceDiagram Alice-&gt;John:连接线 John–&gt;Alice:返回连接线 Alice-&gt;&gt;John: 发送同步调用消息 John–&gt;&gt;Alice:返回同步消息 Alice-xJohn: 发送异步调用消息 John–xAlice: 返回异步消息 12345678910111213标记分类- 代表实线 ， 主动发送消息，比如 request请求&gt; 代表实心箭头 ， 同步消息，比如 AJAX 的同步请求&gt; -- 代表虚线，表示返回消息，spring Controller return&gt;&gt; &gt; 代表非实心箭头 ，异步消息，比如AJAX请求---## 便签+ **代码**&lt;br&gt; 具体规则 &lt;font color = red&gt;Note&lt;/font&gt; [right of | left of ]&lt;font color = red&gt; 对象:&lt;/font&gt;文本 +1234sequenceDiagram participant John Note left of John: Text in note+ 1+ **效果**&lt;br&gt; sequenceDiagram participant John Note left of John: Text in note1234567---## 跨越两个Actor的便签+ **代码**&lt;br&gt; 具体规则 &lt;font color = red&gt;Note&lt;/font&gt; [over]&lt;font color = red&gt; 对象A,对象B:&lt;/font&gt;文本 +1234sequenceDiagramAlice-&gt;&gt;John:Hello John, how are you?Note over Alice,John:A typical interaction+ 1+ **效果**&lt;br&gt; sequenceDiagramAlice-&gt;&gt;John:Hello John, how are you?Note over Alice,John:A typical interaction1234---## 循环Loops+ **代码**&lt;br&gt; +123456sequenceDiagram Alice-&gt;&gt;John: Hello! loop 循环逻辑 John-&gt;&gt;Alice:Great! end+ 1+ **效果**&lt;br&gt; sequenceDiagram Alice-&gt;&gt;John: Hello! loop 循环逻辑 John-&gt;&gt;Alice:Great! end1234---## 选择ALT+ **代码**&lt;br&gt; +12345678sequenceDiagram Alice-&gt;&gt;Bob: are you OK? alt not well Bob-&gt;&gt;Alice:not so good :( else is OK Bob-&gt;&gt;Alice:Feeling fresh like a daisy:) end+ 1+ **效果**&lt;br&gt; sequenceDiagram Alice-&gt;&gt;Bob: are you OK? alt not well Bob-&gt;&gt;Alice:not so good :( else is OK Bob-&gt;&gt;Alice:Feeling fresh like a daisy:) end1234---## 可选opt+ **代码**&lt;br&gt; +123456sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? opt Extra response Bob--&gt;&gt;Alice:Thanks for asking end+ 1+ **效果**&lt;br&gt; sequenceDiagram Alice-&gt;&gt;Bob: Hello Bob, how are you? opt Extra response Bob–&gt;&gt;Alice:Thanks for asking end `]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法示例]]></title>
    <url>%2F2019%2F01%2F01%2FMarkdown%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[目录 [TOC] 脚注 代码 123《十一种孤独》[^3]是一本描写低端人口[^1]xxx[^3]: 一本书名[^1]: 低端人口 效果《十一种孤独》^3是一本描写低端人口^1xxx 字符样式 代码 1234567- [ ] 注意前中后的空格- [x] 有时候不是很方便- [] ~~像这样~~- [ ] ~~应该是这样~~&lt;br&gt;*&amp;nbsp;&amp;nbsp;斜体字符*&lt;br&gt;**粗体字符**&lt;br&gt;~~删除线的文字~~&lt;br&gt; 效果 注意前中后的空格 有时候不是很方便 [] 像这样 应该是这样&nbsp;&nbsp;斜体字符粗体字符删除线的文字 字体调整 代码 1234567&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;br&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;br&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;br&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;br&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;br&gt;&lt;font color=gray size=3&gt;Size：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是3&lt;/font&gt;&lt;br&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange但有道不支持&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果我是黑体字我是微软雅黑我是华文彩云color=#0099ff size=72 face=”黑体”color=#00ffffSize：规定文本的尺寸大小。可能的值：从 1 到 7 的数字。浏览器默认值是3 背景色是：orange但有道不支持 缩进 代码 123一个字：全方大的空白&amp;emsp;或&amp;#8195;空白&lt;br&gt;½个字：半方大的空白&amp;ensp;或&amp;#8194;空白&lt;br&gt;⅓个字：不断行的空白&amp;nbsp;或&amp;#160;空白&lt;br&gt; 效果一个字：全方大的空白&emsp;或&#8195;空白½个字：半方大的空白&ensp;或&#8194;空白⅓个字：不断行的空白&nbsp;或&#160;空白 图片 代码 1![这里写图片描述](http://img3.douban.com/mpic/s1108264.jpg) 效果 链接 代码 123456This is an [link](http://example.com/).I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ [2]: http://search.yahoo.com/ [3]: http://search.msn.com/ 效果This is an link.I get 10 times more traffic from Google than from Yahoo or MSN. 反斜杠转义符 代码 1234567891011121314\* 字符星号 \*Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 效果* 字符星号 * 流程图(有道支持) 代码 123456TB，从上到下TD，从上到下BT，从下到上RL，从右到左LR，从左到右+ graph TD B((开始)) B–&gt;C(圆角方框) C-.-&gt;J(虚线) J-.标签.-&gt;K(虚线标签) B—D[方脚方框] D==&gt;H[粗线] H==标签==&gt;I[粗线标签] B–标签—E{yes or no} E-.-&gt;|yes| G&gt;非对称节点] E–&gt;|no|B G–标签–&gt;F((结束))+12```+ **效果**&lt;br&gt; graph TD B((开始)) B–&gt;C(圆角方框) C-.-&gt;J(虚线) J-.标签.-&gt;K(虚线标签) B—D[方脚方框] D==&gt;H[粗线] H==标签==&gt;I[粗线标签] B–标签—E{yes or no} E-.-&gt;|yes| G&gt;非对称节点] E–&gt;|no|B G–标签–&gt;F((结束))1234---# subgraph（子图）(有道支持)+ **代码**&lt;br&gt; +123456789101112graph LR subgraph g1 a1--&gt;b1 end subgraph g2 a2--&gt;b2 end subgraph g3 a3--&gt;b3 end a3--&gt;a2+ 1+ **效果**&lt;br&gt; graph LR subgraph g1 a1–&gt;b1 end subgraph g2 a2–&gt;b2 end subgraph g3 a3–&gt;b3 end a3–&gt;a212345---# 时序图(有道支持)具体详解请参照[时序图详解](http://note.youdao.com/noteshare?id=82dc781024110d7094f91c40f0ec73ad&amp;sub=5942A3BDD72A48BF9A866A398B7C772B)+ **代码**&lt;br&gt; +123456789101112sequenceDiagram participant 张三 participant 李四 张三-&gt;赵五:Hello 赵五, how are you? loop Healthcheck 赵五-&gt;赵五:Fight against hypochondria end Note right of 赵五:Rational thoughts &lt;br/&gt;prevail... 赵五--&gt;张三:Great! 赵五-&gt;李四: How about you? 李四--&gt;赵五: Jolly good!+ 12+ **效果**&lt;br&gt; sequenceDiagram participant 张三 participant 李四 张三-&gt;赵五:Hello 赵五, how are you? loop Healthcheck 赵五-&gt;赵五:Fight against hypochondria end Note right of 赵五:Rational thoughts prevail… 赵五–&gt;张三:Great! 赵五-&gt;李四: How about you? 李四–&gt;赵五: Jolly good!12345---# 甘特图(有道支持)+ **代码**&lt;br&gt; +1234567891011121314151617gantt dateFormat YYYY-MM-DD title 这里写标题 section 预定日程 完成task :done, des1, 2014-01-06,2014-01-08 处理中task :active, des2, 2014-01-09, 3d 未来task1 : des3, after des2, 5d 未来task2 : des4, after des3, 5d section 紧急日程 紧急完成task :crit, done, 2014-01-06,24h 紧急预定task之后 :crit, done, after des1, 2d 测试 :crit, active, 3d 未来task1 :crit, 5d 未来task2 :2d 未来task3 :1d+ 12+ **效果**&lt;br&gt; gantt dateFormat YYYY-MM-DD title 这里写标题 section 预定日程 完成task :done, des1, 2014-01-06,2014-01-08 处理中task :active, des2, 2014-01-09, 3d 未来task1 : des3, after des2, 5d 未来task2 : des4, after des3, 5d section 紧急日程 紧急完成task :crit, done, 2014-01-06,24h 紧急预定task之后 :crit, done, after des1, 2d 测试 :crit, active, 3d 未来task1 :crit, 5d 未来task2 :2d 未来task3 :1d1234---# UML图(有道不支持)+ **代码**&lt;br&gt; +1234张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。+ 123456+ **效果**&lt;br&gt; ![4](https://note.youdao.com/yws/public/resource/6d8875e5a015a2531827e3d1b3043da5/xmlnote/6CAE96D148C149E3940BAF36AA942321/10830)---# 流程图(有道不支持)+ **代码**&lt;br&gt; +12345678910111213st=&gt;start: 开始e=&gt;end: 登录 io1=&gt;inputoutput: 输入用户名密码 sub1=&gt;subroutine: 数据库查询子类 cond=&gt;condition: 是否有此用户 cond2=&gt;condition: 密码是否正确 op=&gt;operation: 读入用户信息st-&gt;io1-&gt;sub1-&gt;condcond(yes,right)-&gt;cond2cond(no)-&gt;io1(right)cond2(yes,right)-&gt;op-&gt;econd2(no)-&gt;io1+ 123456+ **效果**&lt;br&gt; ![5](https://note.youdao.com/yws/public/resource/6d8875e5a015a2531827e3d1b3043da5/xmlnote/938C79ACD12F4BFAB59720FF9C6D77DD/10850)---# 锚点+ **代码**&lt;br&gt; 目录//跳转到这里` 效果目录//跳转到这里]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Github+Hexo搭建个人博客]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[[TOC] 1. 需要安装的软件 安装 Node.js 下载Node.js 安装 Git 下载Git 安装Hexo，1和2装完成后，即可使用 npm 安装 Hexo。$ npm install -g hexo-cli 2. Git配置 配置Github的账号和密码12$ git config --global user.name &quot;jackychen88&quot;$ git config --global user.email &quot;chenlongxxxx@126.com&quot; 3. 配置Github的repositories 新建Github网站资源库 重命名资源库名，以后次名字可以直接通过url来访问 配置Github Pages 获取网页部署url,下面步骤的配置文件_config.yml文件中配置的网址 4. 设定本地电脑Blog文件源码仓库 在任意磁盘处新建一个空文件夹作为我们Blog的代码仓库，例如G:\GitHub\Blog 在G:\GitHub\Blog里右键选择Git Bash here进入Git 命令输入界面 初始化Blog代码$ hexo init blog,稍微等待一会，加载速度比较慢，提示成功后会在G:\GitHub\Blog下生成几个文件夹和文件 配置Blog的配置文件_config.yml文件，修改参数信息，以便以后每次新建内容的时候带出一些预设值，和能mapping上我们的github（特别提醒，在每个参数的：后都要加一个空格） 修改Blog的标题和作者信息 12345678# Sitetitle: Jacky&apos;s Blogsubtitle: Programer for ABAPdescription: keywords:author: Jacky chenlanguage: zh-CNtimezone: Asia/Shanghai new_post_name每次新建时的md文件名，带出年月日一边管理 12new_post_name: :year-:month-:day-:title.md # File name of new postsdefault_layout: post deploy 用来关联hexo deploy时推送到github的资源仓链接（上面创建github的网址） 1234deploy: type: git repo: https://github.com/Jackychen88/jackychen88.github.io.git branch: master 发表博客文章，使用下面命令后会在G:\GitHub\Blog\source_posts下自动生产一个md文件,生成后可自行修改md的内容，其实就是在更新Blog内容 1$ hexo new &quot;如何使用Github+Hexo搭建个人博客&quot; 编译并测试Blog是否能在本地运行,运行完下面命令后可以在http://localhost:4000/ 中查看Blog是否正常运行 123$ hexo clean$ hexo generate$ hexo server 5. 推送至Github的资源仓库 本地编译成功后推送到Github的资源仓库中去 （如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误npm install hexo-deployer-git --save） 1$ hexo deploy 至此，就可以直接用https://jackychen88.github.io 这个url访问blog了 5. 推送Blog源码到Github资源库 为了能在不同电脑上都能方便的去发布Blog，可以将Blog的源码也推送到Github上去，主要有以下几个步骤 github上创建blog源码的资源库 在本地使用git init来跟踪源码文件夹下的所有文件 git add .增加文件 git commit -m &quot;提交描述&quot;来commit修改 git remote add blog https://github.com/Jackychen88/Blog.git来添加访问资源库的链接，注意blog可以自己命名 git push blog master 推送次文件夹内容到github对应仓库，注意若推送失败尝试先获取罪行github的资源仓内容git pull blog master]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F12%2F31%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[折腾了半天，个人博客终于搭建成功了，为表庆祝，放上女儿的靓照]]></content>
  </entry>
</search>
